#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
//笔试题1
//int main()
//{
//	int a[5] = { 1, 2, 3, 4, 5 };//不明白就看看视频吧，当时自己做错了
//	int *ptr = (int *)(&a + 1);//&a+1是数组指针，所以要强制类型转换为整型指针
//	printf("%d,%d", *(a + 1), *(ptr - 1));
//	return 0;
//}


//笔试题2

//由于还没学习结构体，这里告知结构体的大小是20个字节    //这个题目挺难的，没有弄明白，以后再看看吧
struct Test
{
	int Num;
	char *pcName;
	short sDate;
	char cha[2];
	short sBa[4];

}*p;
//假设p 的值为0x100000。 如下表达式的值分别为多少？
//已知，结构体Test类型的变量大小是20个字节
int main()
{
	p = (struct Test*)0x100000;//由以前学的知识可以知道，内存中存储的都是十六进制
	printf("%p\n", p + 0x1);   //p是结构体指针，结构体指针加1，跳过一个结构体的字节数，结构体20个字节，所以要加20（因为p+1到底加几取决于指针类型，
	//字符指针加1跳过1个字节，整型指针加1跳过4个字节，结构体指针加1，跳过一个结构体的字节数，结构体20个字节，所以要加20）
	//p+0x1=0x100000+0x1(0x1就是1，说明加20个字节)，(0x1是十六进制1，十六进制1的十进制也是1)
	// 0x100000+20=0x100014(十进制的20转换为十六进制就是14)，因为打印的是地址，
	// 打印前补全十六进制位数:0x00100014,打印出00100014
	printf("%p\n", (unsigned long)p + 0x1);
	//十六进制的0x100000转换为十进制是1048576，十六进制0x1转换为十进制是也是1，1048576+1=1048577
	//1048577转换为十六进制是0x100001，因为打印的是地址，
	// 打印前补全十六进制位数:0x00100001,打印出00100001

	printf("%p\n", (unsigned int*)p + 0x1);//把p强制类型转换为unsigned int*的0x100000(十六进制)，十六进制0x1转换为十进制是也是1
	//unsigned int*去加1跳过4个字节，所以0x100000+4=0x100004,因为打印的是地址，
	// 打印前补全十六进制位数:0x00100004,打印出00100004
	return 0;
}
//笔试题3
//int main()
//{
//	//这个题目听明白了，但是需要多看看视频
//	int a[4] = { 1, 2, 3, 4 };
//	int *ptr1 = (int *)(&a + 1);
//	int *ptr2 = (int *)((int)a + 1);//a是数组名，数组名是首元素的地址，也就是1的地址，1的地址强制类型转换为一个整型，也就是转换为一个整数，整数加1也就只是
//	                                //让它向后加了个1，加1之后产生的这个数字如果作为一个地址的话，比不加1向后偏移了一个字节，因为地址变了一个1
//	                                //((int)a + 1)再强制类型转换为地址：(int *)((int)a + 1)，比不加1之前向后偏移了一个字节，后续分析具体看下面的图片
//	printf("%x,%x", ptr1[-1], *ptr2);
//	return 0;
//}

//笔试题4

//#include <stdio.h>
//int main()
//{
//	int a[3][2] = { (0, 1), (2, 3), (4, 5) };
//	//逗号表达式，上面的数组其实就是 int  a[3][2]={1,3,5};
//	//这个二维数组是
//	//1 3
//	//5 0
//	//0 0
//	int *p;
//	p = a[0];//a[0]是二维数组的第一行的数组名，没有sizeof(a[0]),也没有&a[0],所以代表的二维数组的第一行的首元素的地址，也就是第一行第一个元素的地址，
//             //也就是1的地址
//	printf("%d", p[0]);//结果是1    p[0]=*(p+0)  这个表达式转换一定要搞明白，记住它就行了，一定要记住
//	return 0;
//}



//笔试题5
int main()
{
	int a[5][5];//这个题目太难了，没有弄明白，去看看视频吧
	int(*p)[4];
	p = a;//这句代码会发生警告，因为a是二维数组的数组名，它代表了数组的首元素的地址，也就是二维数组第一行的地址，a的类型是：函数指针类型
	//即int (*)[5](写5是因为第一行有5个元素)，而p的类型是：int(*)[4]（去掉数组名就是变量的类型）
	//int (*)[5]和int(*)[4]类型不同，所以会发生警告（虽然会发生警告，但还是可以正常把a赋值给p的）
	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//a[4][2]很容易找到，但p[4][2]不容易找到
	//p[4][2]化简：*(p+4)+2=*(*(p+4)+2)

	//&p[4][2] - &a[4][2]的值为-4
	//-4的原码：10000000 00000000 00000000 00000100
	//-4的反码：11111111 11111111 11111111 11111011
	//-4的补码：11111111 11111111 11111111 11111100
	//11111111 11111111 11111111 11111100的十六进制是：ff ff ff fc,即fffffc
	//%p:以地址的形式打印-4，需要把-4转化为内存
	//以%p形式打印，认为内存中存放的就是地址，我们认为地址不存在原、反、补、正数和负数的概念，直接把补码打印，我们认为内存中的补码就是它的原码，
	//直接拿出来当成地址打印（内存中的地址都是十六进制存在的，这个知识点之前已经掌握了)
	//%d:以%d整型打印-4，-4就是整型的，可以直接打印出-4就行
	return 0;
}

//笔试题6
//int main()
//{
//	int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };//这个题目弄明白了，这种题目要多看看视频，对理解指针有好处
//	int *ptr1 = (int *)(&aa + 1);
//	//&aa是二维数组的地址，&aa + 1仍然是二维数组的地址，二维数组的地址是一个数组指针类型，不能直接赋值给整型指针int *
//	//所以要用(int *)进行强制类型转换(只是让类型发生了变化，它的值还是那个位置的地址)
//	int *ptr2 = (int *)(*(aa + 1));
//	//aa是二维数组的第一行的地址，aa + 1是第二行的地址，*(aa + 1)就是对第二行进行解引用，相当于找到了第二行 ，就是拿
//	//到了第二行的数组名，因为*(aa + 1)=aa[1],而aa[1]就是第二行的数组名，arr[1]表示的是第二行首元素的地址（因为数组名
//	//表示的是首元素的地址，前题是没有进行 sizeof(数组名) 和没有进行 &数组名 运算的情况下，数组名表示的是首元素的地址），
//	//也就是6的地址
//	//就是说*(aa + 1)表示的是6的地址，它本来就是整型指针int *，所以根本不需要在前面进行强制类型转为整型指针(int *)，这个
//	//强制类型转换完全是多余的，没有任何是价值
//
//	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));//10 5
//
//	//整型指针减1，向前移动1个整型
//
//	return 0;
//}



//为什么*(aa + 1)=aa[1]
//int main()
//{
//	int arr[10] = { 1, 2, 3, 4, 5 };
//	int* p = arr;
//	//*(p + 2) 等于 arr[2]，而有int* p = arr可以知道，p等于arr，所以*(arr + 2) 等于 arr[2]，即*(arr + 2) == arr[2]
//	//这个规律对于二维数组一样适用
//	return 0;
//}




//笔试题7
//这道题视频听明白了，还是要多看看视频，这道题目知识点很多，长时间不看容易忘记
//int main()
//{
//	char *a[] = { "work", "at", "alibaba" };
//
//
//	char**pa = a;
//	pa++;
//	printf("%s\n", *pa);//at
//	return 0;
//}



//笔试题8
//这道题视频听明白了，还是要多看看视频，这道题目知识点很多，长时间不看容易忘记
//这道题目太牛逼了，我都听明白了，后续要经常看看，这个题目太难了，也太好了，我听明白了，还是挺开心的
//int main()
//{
//	char *c[] = { "ENTER", "NEW", "POINT", "FIRST" };
//	char**cp[] = { c + 3, c + 2, c + 1, c };
//	char***cpp = cp;
//	printf("%s\n", **++cpp);//POINT
//	printf("%s\n", *--*++cpp + 3);//ER    ++优先级最高，*优先级次之，+优先级最低
//	printf("%s\n", *cpp[-2] + 3);//ST     *cpp[-2] + 3)=**（cpp+(-2)）+3=**(cpp-2)+3
//	printf("%s\n", cpp[-1][-1] + 1);//EW  cpp[-1][-1]+1=*(cpp+(-1))[-1]+1=*(cpp-1)[-1]+1=*  (*(cpp-1)+(-1))+1=*  (*(cpp-1)-1)+1=*(*(cpp-1)-1)+1
//	return 0;
//}